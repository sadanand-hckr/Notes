Virtualbox Management -> https://academy.ehacking.net/courses/551622/lectures/10002215
http://www.networkpentest.net/p/linuxunix-command-list.html
https://stackify.com/linux-logs/
netstat --inet -n // 

cmd -curl ifconfig.me // to know own public ip address

  iptables ->
  iptables contains of 5 tables out of which 3 r main tables 
  Table1(Filter table) -> this is the default ip table for packet filtering
  Table2(NAT table ) -> this table is used to odify or hos to modfy the packet source or destination addressess in order to
  route the packet in NAT setup where direct access is not possible
  Table3(Mangle table) -> this table is used to alter the IP tables of of the packet such as TTL value of the packet etc
  other 2 tables r RAW table which is used for connection tracking it provides mechanism for marking packets to view the
  packets as part of the ongoing connection or session and Security table is used to set internal SELinux security context
  marks on packet which will affect how SELinux or other system that can interpret SELinux
  
  Chains r like points in the route of a packet where u can apply rules their r 5 chains in IPtable, Screenshot(542)
	- pre routing // it is applied to any incoming packet as soon entering the network stack this chain is process before taking
	any routing decision have been made regarding where to send the packet
	- input // this is the point post pre-routing when packet enter the system
	- forward // it is applied to the packet that is forwarded through ur system
	- output // it is applied to the packet originated thorugh ur system
	- post routing // this is opposite of pre-routing this is applied to outgoing packet after routing decision has taken place
	and just before packet has been put on the wire 

all chains r not avaible for all tables each chain gives u the option to take action on the packet on that particular
	point of the packet route
	

	To determine which chain is avaibale for which table -> Screenshot(543)
	Traversal order -> Screenshot(544)
	
	Ex -> iptables -A INPUT -s 15.15.15.15 -j DROP // to block an ip address
	-s is for matching component can be defined for ip address, port address, interfaces, headers
	-j is target component is the action to be triggered when the packet meets the matching critaria of a rule 
	
	their r 2 types of target terminating(these r actions that end the furher traversal in that particular chain, Ex ->
	Accept, Drop, Queue, Reject, Return, User-defined) and non-terminating target(u perform an action and continue evaluation
	within the chain not all action is avaiable for every chain in table )
	
	cmd -> iptables -L -n -v  // L to list, n for numeric , v for verbose their it will putput filter table
	
    cmd -> iptables -t mangle -L -n -v // t for telling table to list
----------------------------------------------------------------------

iptables -L // to view tables rules

iptables -P FORWARD DROP // to Drop the default policy FORWARD which is out of 3 plicies INPUT and OUTPUT

iptables -A INPUT -s ip_address -j DROP// A to append rule to policy INPUT and -s as source address and -j 
tells to block the traffic coming from source address

iptables -A INPUT -s ip_address/24 -p tcp --destination-port 25 -j DROP // of protocol tcp, this will
 block traffic from the source network for every device for smtp port 25

iptables -A INPUT -s ip_address -j ACCEPT // this will allow to except from this IP 

Note : above mentioned ACCEPT rule should be before the netowrk DROP rule bcz the rules r readen from top
to bottom and it the DROP rule runs first the ACCEPT rule will never got the chance to run if it is of same 
network as in 192.168.0.0/24 for DROP and 192.168.0.15 for ACCEPT

iptables -D INPUT rule_no // -D to delete, from top to bottom (0 not included)

iptables -I INPUT -s ip_address -j ACCEPT // -I for adding too except the -I add to atart and -A add to end
 the rule


- Basic difference between Linux flavours is that Ubuntu or Debian based flavours use 'apt-get' and fedora or other same one
uses the 'yum' 

Wildcards ->
* - represents zero or more characters
? - represents single character
[] - represents range of characters
\ - as an escape character
^ - the beginning of the line
$ - the end of the line
{} widlcard, Ex -> touch abcd{1..9}-xyz // this will create 9 files with name as abcd1-xyz to abcd9-xyz
cmd  -> ls -l abc*   // list all files start with 'abc'
cmd -> ls -l ?bc*   // ? here is representing single unknown character
cmd -> ls -l *[cd]*  // list all files with either 'c' or 'd'

open image cmd -> xdg-open filename

File System Paths -> Two types Absolute and Relative Paths
Absolute path always begins with '/' this indicates that the path starts at root directory
Ex -> cd /var/log/samba
Relative path doesn't begin with '/' it identifies the position relative to ur current position
Ex -> cd log  // it is relative to var directory as it is inside var directory

- Each OS has a different protocol or client that is used to access the system
	Ex -> windows - Remote Desktop(RDP)
	      VMware ESX - vSphere client
	      Linux - Putty, SecureCRT or SSH from Linux to lInux
	      
Linux File types ->
	- = Regular file
	d = directory
	l = link
	c = special file or device file
	s = socket
	p = named pipe
	b = block device


- updatedb // this will build the database for file and directory, use this before using locate but not all the time, once
 when u start using kali linux just execute it in starting.

- locate file_name // the locate will help u to find the file in whole computer or all the directories and places

- find // on executing it, this will search for everything
- find /etc -name file_name // now this will search the file only in etc folder, so put the location in 2nd param 
- find /etc -name p* // this will search for every file which starts with p in the given location

'locate' uses a prebuilt database, which should be regularly updated, while 'find' interates over a filesystem to locate
files, thus locate is much faster then find, but can be inaccurate if the database(can be seen as a cache) is not updated

Soft and Hard Links -> Screenshot(358)
to create a soft link use cmd -> ln -s full_path_to_file // to verify if link is done to ls -al and u will see that the
filename is directing to the path of the file, now if u will do the change in the original file then the link file would
be also change accordingly -> ls -li // to list the inodes
The inodes for the soft link is different from the original file of which it is link and if the original file is deleted
the content in the soft link will also not appear as the file is removed but in hard link even if the original file is
removed the hard link file still show the content.
Note for hard link -> Screenshot(359)
When a hard link is created it would not be shown as 'link' in details instead shown as normal file and also when u do
ls -al u will not see the filename is directing to the path of the file like in soft link

File System Structure and its Description -> Screenshot(362)



Run multiple cmds together -> we can use ';' for combining cmds
- ls ; pwd          // now the o/p would be combination of both cmds and they will be executed from left to right
- date ; CAL ; pwd  // here 'CAL' is a wrong cmd but still other cmds will be executed it will just gave the error for 2nd cmd
- ls && pwd         // we can use '&&' in place of ';' and gives the same output
- the only difference between ';' and '&&' is that the ';' will execute every cmd regardless of other cmds have been executed
  successfully of not but with '&&' if the previously executed cmd is failed it will not execute the other left cmds
- ls || pwd         // here it will give output for 'ls' only bcz here logical OR is applied as if any of the cmd is successful
                    // it will not execute other cmds

- ls        		// To list the files present in directory
- ls option_cmd directory_name      // syntax for ls cmd
- ls Documents          // this will list all the files which r in Documents directory
- ls -al                // this will show the hidden files and the details about all files
- ls -ltr		// to list every thing in timely reverse order 
- ls -li 		// to list the inodes 
- ls -sh		// to display size in human readble format

Note -> on doing cmd in home directory -> ls -ltr // u might see that the username and groupname for the user is same even
after changing it and the reason for that the actual group of the user will always remain the username it is just now part
of the another group to change it properly use the 

cmd -> chgrp -R groupname username // this will make changes to every folder of the username 

- mkdir directory_name // to create the directory

- rm filename                       // to remove a file
- rm -r parent_directory_name       // this will remove the file and the directory's also

- cp options_cmd src des        // 'cp' is used as copy command 'src' is the source from which we wants to copy and 'des' is
                                // the destination where we wants to copy
- cp file1 file2                // this will copy data of file1 to file2 and create file2 if it does not exist
- cp file1 dir1                 // this will copy file1 to dir1 directory

- mv options_cmd src des // syntax for mv
- mv file1 file2 // this will move data and rename file and directories so here file1 will be renamed as file2 and if file2
                 //  doesn't exist it will be created
- mv file1 dir1 // this will move file1 to dir1 directory and if file1 exists then the data in it will be overwritten
- mv -v file1 dir1      // for the verbose mode

- cat options_cmd filename1 filename2 .... // syntax for cat
- cat               // this will allow u to write something on terminal and echo things u enter
- use ctrl+d to come out of 'cat' cmd
- cat file_name // to display contents of the file
- cat filename1 filename2 // this will combine and display the contents of two files

- 'touch' cmd is a way to create files in linux it is also used to change the timestamps on existing files and directories, u 
  cannot use 'touch' cmd to create directories
- touch filename                        //syntax to create a new file
- touch hello.sh  //.sh extention is not necessary but for editor it is usefull, it is also best practice to provide extension
- touch file1     // file1 should be already exist now the timestamp of the file would be the current time

VIM Editor ->
- sudo apt-get install vim // to install vim
- vim name_of_file_to_edit // open the editor with file open
- vim file.txt // to create a file
      - press i // to insert
      - press esc to exit the insert mode
      - :w // to save
      - :q // to exit
      - :wq // to save and close the file or we can also use ZZ for the same task
      - :q! // to exit file without saving
      - press o // to get into the next line , don't press it in the insert mode

- nano filename // this will create the file if not exists
- ctrl+o // to save the data in file and then press enter
- other common cmds which will be used in nano editor will be already listed at bottom of the editor



Note -> If U get permission denied while listing of files with any command then use 'sudo' with that cmd

- cmd -> echo $SHELL , o/p -> the path to the shell which is being used

- cd /root/Desktop  // this navigation is also correct, no need to 1st execute cd ~ then go to Desktop
- ls /home/          // to know the users
- cd /home/username  // to navigate to userbased directory

- pwd       // This cmd shows the current working directory

- whoami // to find who is logged in the system at current
- visudo  /etc/sudoers  // it is to edit file which is configuration file that allows u to add or remove the rights to run 
cmds look for the string 'wheel' the users in this group can run all cmds -?? 
- hostname // It is used to obtain the DNS(Domain Name System) name and set the system's hostname or NIS(Network Information
System) domain name. A hostname is a name which is given to a computer and it attached to the network. Its main purpose is 
to uniquely identify over a network.
- hostnamectrl -set-hostname newhostname // to change the hostname
  place where the changes r done for hostname -> /etc/hostname


- cat /etc/os-release // to get info of OS
- uname -a // for kernel info
- sudo dmidecode // to get proper and detailed info for the system


- history // to know the cmds executed
- !cmd_no. // the history cmd gives the cmd no. for the cmds we can use it's no. to execute the cmd
- path for the history cmds saved -> home/username/.bash_history

- sudo init 6 or reboot // to restart the machine
- init 0 or shutdown // to shutdown the machine
- init 3 // multi user mode
- halt // it shudown the computers and if their r processes that need some time to come down it doesn't care as it shutdown
  rightaway 

- 'head' and 'tail' cmds generally we use them with files, So 'head' cmd could be used to output the first part of the file and
  the 'tail' cmd could be used to output the last part of the file
- Bydefault 'head' will print first 10 lines and 'tail' will print last 10 cmds
- head file_name        // syntax for head
- tail file_name        // syntax for tail
- head -nNumber_of_lines file_name  // to give limit for the no. of lines to display, no space between -n and Number_of_lines
- tail -nNumber_of_lines file_name  // to give limit for the no. of lines to display
- head -Number_of_lines file_name   // works same as cmd -> head -nNumber_of_lines file_name 
- head file1 file2          // to see first 10 lines of multiple files
- head -Number_of_lines file1 file2     // to see first desired number of lines for multiple files

- sort filename // this to sort the data in the given file based on Alphabets

- nl filename // this to display the file with no.'s on the terminal
- nl -s '# ' -w 6  filename // this to display the file with no.'s with # displayed after no.s on the terminal using the
	flag '-s' and '-w' is the no. width used to display data properly


- 'wc' cmd or wordcount prints a count of new lines, words and bytes for each input file
- wc file_name  // o/p -> 1 6 42 file_name , here ist param '1' represents the no. of lines in file, 2nd param '6' represents
                // the no. of words and 3rd param '42' represents the no. of characters in file and 4th is name of file
- wc -c file_name   // this will give the no. of bytes or no. of characters in file
- wc -l file_name   // this will give the no. of lines in file
- wc -w file_name   // this will give the no. of words in file
- wc -L file_name   // this will give the length of the longest line in file

- tac filename // tac is opposite of cat as it displays the data from top to bottom

- cat filename|sed 's/t/T'	// here in 's/t/T' the 's' is for substitude hence it will replace the 't' with 'T' for every
		first 't' char in the file
		Note -> These changes will not be saved

- sed 's/t/T/g' filename // here in 's/t/T/g' the 'g' which is global is to tell that substitude every 't' character with 'T'

- sed -i 's/t/T/g' filename // here in 'i' will make the changes to the original file
Sed tutorial -> https://academy.ehacking.net/courses/551622/lectures/10003044

- 'grep'(global regural expression print), 'grep' cmd processes text line by line and print any line which matches the 
  specified pattern, So 'grep' cmd could be used to search some kind of pattern or word or sentence in a text file or
  no. of text file
- grep "word_or_text_to_search" file_name // this cmd will search the entered word from the input file, and the 'grep' cmd is     
                                         // sensitive case hence the exact word or text would be searched 
- grep -i "word_or_text_to_search" file_name  // to make the search not case-sensitive
- grep -n "word_or_text_to_search" file_name  // to print the line no. with output 
- grep -c "word_or_text_to_search" file1 file2 file3  // to search in multiple files, -c will count the word or text
- grep -n "word_or_text_to_search" *      // to search from all the files
- grep -nv "word_or_text_to_search" file_name    // this will o/p all the lines which doesn't contain the input text

- 'less' cmd is used for reading the file or to search something inside the file, 'less' is better then the cat cmd to read
  the  file contents as the size of the opened terminal window will not create any hurdle to display the data which was too
  big and we were not able to scroll further in terminal
- less filename     // to read the data from the file and scroll the content of file as u proceed by scrolling
    - press space after executing above cmd will display the data on terminal page by page
    - press shift + B to go up the pages
    - press shift + G to go at end of the file
    - press g       // this go at the top of the file
    - /book         // this is search for the 'book' keyword in file and to go to next 'book' in file press 'n'
    - ?book         // to search for 'book' in file from down to up
    - press 'q' to quit from less



# Process Management 

Note -> - Applications and Linux r also known as Service
	- Shell Script is a package of cmds in a file
	- When u run a application it generates process and it's process it
	- Daemon is something which contiounously runs in the background, Ex 'ntp' is process while 'ntpd' is daemon
	- Every process could have a multiple threads in background
	- Job is created by schedular to run those applications and services 

- 'top' cmd provides dynamic real time view of ur system, Suppose u wants to know which process in ur computer is taking most
of the CPU etc then use cmd -> top // a window will appear with data, Here PID -> Process ID, in linux every program and 
process has it's own ID, u can see CPU usage, Memory usage etc
- 'top' refreshes the data of process usage table in every 3 seconds bydeafult
- U can change the delay time from 3 seconds to other interval also by pressing 's' after 'top' cmd is executed
- To filter out ideal processes(processes u need not to know as they will always we running) press 'i'
- To kill any process press 'k' and then enter the 'pid' of the process

- pidof process_name // to find the pid of process

- kill -flags pid_of_process        // syntax for kill cmd
- kill pid_no                       // to kill the process
- kill -KILL pid_no                 // this will force kill only use when needed
- kill -9 pid_no                    // this also a kind of force kill but not as powerfull as -KILL
- pkill procecss_name     // this is used to kill process via name

- ps -ux | grep service_name  // to get the long list of all running processes this is usefull in knowing the name of process
                    //or the process id of some process and use grep to find particular process
- ps -aux           // the 'ps -ux' gives processes list for the current user only, to know all the processes by all users use
                    // 'ps -aux' cmd
- ps -U user_name   // this will give all the processes of the entered user
- ps -C name_of_process     // this will list out all the instances or processes which r related to process entered
- imp cmd -> ps -ef // display current processes

- nice // it is used to prioritize process, Ex -> nice -n 5 procecss   // this will tell the process to be in top 5 priority
                                                                       // process
 	Note -> the niceness scale goes from -20 to 19, The lower the no. the more priority it has

- systemctrl or service, Ex -> systemctl restart ntpd
- crontab // is used to schedule scripts, cmds in system
	Ex -> crontab -e // this will open an editor mode
		> 22 13 * 3 * echo "This is crontab" > crontab -entry   // here 22 is the date, 13 is the time to change 
		and '* 3' tells that how many times to repeat this
		
		Types of Cronjobs -> Hourly, Daily, Weekly, monthly // u can add cronjobs in their directories on system as
		path /etc/cron.daily, /etc/cron.hourly and so on
		The timing for each is set in - /etc/anacrontab  // except hourly as it is in 
		Ex to set -> https://academy.ehacking.net/courses/551622/lectures/10003185
		
- at // it is like crontab except at is scheduled one time basis

- Background cmds -> first start a process // as the process is not run it will not give u prompt back to do additional tasks
		     use ctrl + z to stop the process
		     jobs // to list what is stoped
		     bg // to put process in background -> https://academy.ehacking.net/courses/551622/lectures/10003186
		     
- Foregroundcmds -> fg // to see the process in background
- To Run process even after exit -> nohup process_name & or u can use this cmd ->
	nohup process_name > /dev/null 2>&1 & // as it will prevent the warnings to occur, on using nohup it will create a file
	nohup.out for all the task nohup is doing
	
- sleep 100 // this will make the system sleep for 100 secs before giving the prompt back
- jobs // this will show the process just stopped
		     
- fg // to bring process back from background -> https://academy.ehacking.net/courses/551622/lectures/10003186

# User Account Management

- cat /etc/group // to list the groups
- cat /etc/shadow // it is for the password of the users we create it
- less /etc/passwd 	// to list the users and follow link to understand the logs ->
	https://linuxize.com/post/how-to-list-users-in-linux/

- 'passwd' cmd allows u to change the password for the user
- sudo passwd user_name // now u can change the password for the entered user if u enter username as root then it will
  change the password for root 

- 'sudo' cmd allows extra privilages as administrator or more then normal user
- 'sudo' infront of any cmd will enhance the privilage criteria for that cmd
- su - // to become root user
- su username // to change user

- Adding a New Non-Root User in Kali Linux -> https://thecrazybastard.com/how-to-add-a-new-user-in-kali-linux/

- 'userdel' cmd is used to delete the user
- sudo userdel user_name // it will delete the user but it will not delete the directory of the user which u can see by using          
  cmd -> ls /home/, Hence the user will be deleted but his data will not
- sudo userdel -r user_name   // this will delete the home directory also with the user
- sudo rm -r /home/mark/      // this will remove all the data of the user, So use it carefully

- 'useradd' cmd is used to create a user
- usermod -G groupname username // to change the group for a user
cmd imp -> useradd -g groupname -s /bin/bash -c "Description msg" -m -d /home/username username // this cmd will done the all
work together mostly used in IT by system admin to add user
    // -m is going to create a default home directory for this
    // user, -s is used for allowing the user to use the shell
    // which we provide and here it is bash 
    // -g is the default user flag and user will be assigned to 
    // the group u mention, always use -g flag with the 'users'
    // group, -c flag is used for providing the comments

- groups                 // this will show u that to which groups ur current user is connected too.
- sudo groupadd name_of_group           // to add the new group
- sudo groupdel name_of_group           // to delete the group
- sudo gpasswd -a user_name group_name  // assign user to a group
- sudo gpasswd -d user_name group_name // to remove user from the group
cmd -> chgrp -R groupname username // this will make changes to every folder of the username 

- login -p username // to login into system


# Monitor User ->
- who // to see how many people r logged in
- w // it is same work as 'who' but gives more detailed info related

- last // this will tell u about the every user logged in ever in system, for not whole list just unique names of all users
logged so far use cmd -> last | awk '{print $1}' | sort | uniq
- finger // it is to do trace of ur user where it is coming from what kind of protocol he is using
- id username //to see uid and gid and to know whether user is existing or not

- uptime - this tells how long the system being up for and load, users etc. Screenshot(521)
- users // to list the users logged in the system
- wall // this will broadcast or msg to anyone who is logged in the linux system -??
- write username_to_send_them // it for specific user to another -??
- exit // to logout from the current user


Note -> In Linux their r 2 types of accounts ->
- local account // which is created normally with above cmds
- Domain/Directory account // when u need to add user for access to 1000 servers then we use these accounts, the client will
send a send a request to the Directory server to authenticate and in response the server tells that the user is authenicated
and allowed to log in, in windows their is AD(Active Directory) here u do the same as u create a Account in Active Directory
of the Windows Server, the protocol used for this task is LDAP protocol to authenticate against a directory
Diff bw AD, LDAP, IDM, WinBIND, OpenLDAP -> https://academy.ehacking.net/courses/551622/lectures/10003046

# Types of help commands -> Screenshot(415)
- man any_cmd (this gives the manual of the cmd) // we can also use --help in the place of 'man' Ex -> any_cmd --help

- 'whatis' cmd will display short manual page discription for cmd -> whatis ls - ??

- which cmd is used to return the path name of a file or a command which we use with this 'which' cmd
- which ls //to know the location of the ls cmd
- In bash scripting it is gud practice to use the full path name as we should use -> '/bin/ls' instead of just 'ls' , bcz some
  OS recognize the 'ls' cmd and some will require u to enter the full path for the 'ls' cmd

# Free resources and Used Resources and System monitoring ->
- df        // this cmd reports the amount of Disk space being used and avilable by ur file system
- df -h     // displays the data in more human readable format
- du        // this cmd is used to estimate and display disk space used by files, navigate into the directory on which u wants
            // to use this cmd and in the last of all listing it will show u the size of the folder
- du -h     // displays the data in more human readable format
- du -sh    // '-s' is for summary , 'h' is for human redable, this will calculate the disk space and all of it used
- du -sh folder_name     // to know the details for the following folder

- dmesg      // it gives the output for the system related warnings etc

- iostat // this is for input and output statictics that how we r communicating among the devices connected to system
- iostat 1 // output the data in every second

Note - if u get the .part on doing the ls while the downloading is going on then it means the download is only partially
        complete

- free      // dispalys the total amount of free and used physical and swap memory in the system as well as the buffer used by
            // the kernel, the data associated by the title-> -/+ buffers/cache // displays the whole memory used by ur machine
- free -b   // 'b' is for byte we can also use 'k' in place of 'b', k is for kilobyte , 'm' is for megabyte, 'g' for gigbyte
            // and 't' for terabyte

- cat /proc/cpuinfo   // to get all CPU related info
- cat /proc/meminfo // to get memory related info

Linux Logs ->
- cat /var/log/syslog   // keeps logging information of system for lot of things
Note -> If u don't keep ur log files in check on linux it will grow too big, check for other logs in '/var/log' directory

Compare Files -> Screenshot(423)
- cmd -> diff file1 file2 // tells the difference between two files line by line
- cmd -> cmp file1 file2 // tells the difference in files in respect of bytes 

- 'tar' cmd is used to create, maintain, modify and extract files which r archived in the tar(Tape Archive) format, tar is an
  archiving file format just like zip file
- tar -cvf        // 'c' for creating an archive, 'v' for verbose, 'f' allows u to specify the file name if it not used then
                  // linux is going to create a Zip file which is going to be system dependent and it's name is not defined
                  // by u
- tar -cvf  name_of_file_u_wants_to_give.tar file_name_which_has_to_be_compresed  // this will compress the file to tar, it's
                                                                                  // better to give .tar extension in the name
                                                                                  // for the file u r going to create
- tar -xvf  name_of_tar_file        // to will decompress the file
- tar -czvf name_of_file_u_wants_to_give.tar.gz file_name_which_has_to_be_compresed //here 'z' will create the file with gz
                                                                                    // format
- tar -xzvf file_name.tar.gz        // to decompress gz format file
Note -> tar cmd is not suitable to compress instead we should use 'gzip'
- cmd -> gzip file_name // this cmd will compress the file
- cmd -> gzip -d file_name // this will uncompress the file

File Display Commands -> Screenshot(422)
- cmd -> cut -c position_no_of_char_in_sentence file_name // this will display the character from each line to the
given position starting from 1.
- cmd -> cut -c position1-position2 file_name	// here we r providing range

- awk '{print $position}' file_name	// this will give the word from the each line at the mentioned position

- file_name |sort |uniq	// it removes the duplicate from the file, always use 'sort' cmd before 'uniq' otherwise uniq
	won't work
	

truncate -> Screenshot(424) // it start removing the size for the file by deleting the data in file from end point in file,
on increasing the size using the truncate cmd it will add the data just increase the size of the file

Combining and Spliting Files -> Screenshot(425) // if u don't put the name for the split file it might name as 'xaa' and next
time it will overwrite the same file with name as 'xaa'

Windows Vs Linux cmds -> Screenshot(426)

apt-get update --fix-missing // to only install which r missing
apt-get install -y openvas	// if we use -y it will not ask for surity to install while installing the module

tee cmd -> Screenshot(418) // if tee is used on the existing file then the data in that file would be overwritten
cmd -> echo 'Data'| tee -a file_name // this will not overwrite the data instead it will append the new into existing data
cmd -> echo 'Data'| tee  file1 file2 file3 // for multiple files

Pipes cmd -> Screenshot(419) 

more cmd -> it display one page data of a file at a time, to display futher data press 'space' button and 'q' for exit

File Maintenance Commands -> Screenshot(420) 

I/O Redirection -> to capture output from one file or program and send it to another file and program
- output_cmd > file_name // syntax for redirection
- cat > file_name // to write something in the file, it will also create file if not created and data will we overwritten if                
                  //  it already contains some data in it
- cat >> file_name // this will append the data with the previous data in the file not overwrite it 
Redirect cmds -> Screenshot(417)
- cat filename1 filename2 > filename3 // this will add the data of filename1 and filename2 and store it in filename3
- cat filename1 >> filename2 // this will add the data of filename1 to filename2

- echo string or echo "string"          // to display the string it is best practice to use "" with string
- myvar="Sadanand"                      // This is variable initialization, don't provide space before and after '='
  echo $myvar                           // to display the value of 'myvar' variable
- echo "My name is $myvar"              // to use variable to display string
- echo -e 'Some \text'                  // here 't' of word 'text' will be escaped bcz we use -e, O/P -> Some ext
- echo -e 'Some \n text'  // o/p -> Some
                                    text
- if u do cmd -> ls -l     // then u will see as o/p -> -rw-rw-r-- 1 sadanand sadanand 22 Jul 23 18:55 test
- Here in the 1st '-' means it's a normal file, if it would be 'd' then it means it is a directory and if it is 'c' then it
  is character special file, if it is 'b' then it is binary special file.,if file is 'l' it is link
- First -rw here is for the owner of the file
- Second -rw means read and write for the group of the file and
- 3rd r-- is the permission for everybody else
- 4th '1' represents the symbolic links of the file
- 5th sadanand it is the name for the owner of the file
- 6th sadanand it is the name for the group of the file
- 7th '22' it is the size of the file
- 8th 'Jul 23 18:55' is the date on which it's created
- 9th 'test' is the file name
- rwx means the read, write and execute
- To change the permissions -> chmod o+x file_name  // Here 'o' stands for others '+' is for adding the permission and '-'
  is for subtracting the permission and x is for executable, So permission for others has now executable permission.
- same way -> chmod o+w file_name    // to set permissions for the others as writeable
- chmod g+x file_name    //  to set the executable permission for group
- chmod g-wx file_name   // to set the permissions for executable and write for the group
- chmod ug=rwx file_name // this will change the permissions for the owner and the group of the file together to read, write
  and execute, '=rwx' and '+rwx' works same way
- chmod a-rwx file_name // we can use 'a' for all to set permissions for read, write and execute we could also use 
  'chmod ugo-rwx file_name' cmd
- chmod u+rw,g=rw,o+r file_name // this is for the setting seperate permissions for owner, group and others together
- chmod u-w directory_name   // to set the permissions for the owner for write in directory and lock symbol will appear on
  the directory on visual(graphical view) folder
- Note -> we can also revoke the permissions for executable from the directory, in which case the user cannot 'cd' into the
  directory

- Octal and Numerical Permissions -> Octal Permission is the numerical representation of the file permission,
 the octal representation for -> -rw-rw-r-- 1 sadanand sadanand 22 Jul 23 18:55 test as

 Users          Groups          Others
 r w x          r w x           r w x   // use 1 for providing the permissions and 0 for not providing permissions
 1 1 1          1 0 1           0 0 0   // taking 1 1 1 for all if we r providing permissions for all which is binary value 
 4 2 1          4 0 1                   // 4 2 1 came in group as we take 1 for 'x' in Users then 'w' become 2 bcz as go from
                                        // right to left in binary the values doubles and for the same reason 'r' is 4
// now 4+2+1 = 7 so now if u wants the owner to read, write and execute the file then u need to give the no. notation 7
// now in groups if we doesn't wants to give the write permission to the group then denote 'w' as 0 as for the negative 
   permissions, 'r' and 'x' as 1 as for the positive permissions
// hence for groups the value notation will be 4+0+1 = 5, So when ever u wants to give only read and execute permission we
   can use '5', So this way we can calculate the notations
// Hence to change permissions -> chmod 000 file_name  // so here we r saying that we r providing no permission for owner
   hence 0,n o permission for group hence 0, no permission for others hence 0 So it becomes 000
// For owner to read, write, execute and for group it is only read and execute hence cmd -> chmod 750 file_name

- If the tab is not completing the script then check the permissions for the file whether it is read only by cmd->'ls -al'
  then do cmd -> 'chmod +x file_name' to do the executable permissions for owner, group and others all together.
- To revert the permissions use cmd -> 'chmod -x file_name'

File Ownership -> Screenshot(414)
cmd -> chown user_name file_name // this will change the owner of the file to the entered user_name
cmd -> chgrp group_name file_name // this will change the owner of the file to the entered group_name
chown owner_name:group_name file_name // this will change the ownership and group together for a file


User Account Manangement cmds -> Screenshot(430)

cal - this cmd is for calculator
bc - this is for binary calculator


- sudo -s       // this will give u the root user privilages which is super user mode
- sudo su    // To go to the root user and give root permissions)
- -su // to login as root

Linux File Editor -> Screenshot(427)
vi or vim cmds -> Screenshot(428)
	    
# Log Monitoring -> https://academy.ehacking.net/courses/551622/lectures/10003190
 path -> /var/log
 	Important files to check in this directory -> boot 
						      cron
						      maillog
						      secure
						      messages
						      httpd
						      


Linux File Types -> Screenshot(357)


Important things to remember -> Screenshot(364)

Linux File System -> Screenshot(365, 366)

Command Syntax -> Screenshot(367)

File Permissions -> Screenshot(368)

route // display existing kernel routing table entries

netcat // https://www.youtube.com/watch?v=Dbz8wQLz2Sw&list=PLZOToVAK85MpiuxbK7Sg6CtQtlW9QygC-&index=4

Tab (Button) in Linux -> Screenshot(416), Press tab 2 times if on one press it doesn't complete the cmd this way it
 will list the available options with the same initials in the cmd or file.

Filters/ Text Processors Commands -> Screenshot(421)

Network Files ->

- /etc/nsswitch.conf // it is tell where to resolve ur hostname and other config files places
- /etc/hosts  // info regarding hostname
- /etc/sysconfig/network or /etc/hostname
- /etc/sysconfig/network-scripts/ifcfg-nic 
- /etc/resolv.conf


ICMP ->
- ICMP (type 11, code 0) denotes Time Exceeded
- ICMP (type 13, code 3) denotes router is blocking ICMP
- ICMP ping and ping sweeps are used to check for active systems and to check, if ICMP ping traverses a firewall
- Test-NetConnection tool for troubleshooting at transport layer, default use ICMPs
- Traceroute cmd uses UDP packets, on windows ICMP packets - https://drive.google.com/drive/u/1/my-drive ques 28
- mtr (linux tool) and pathping (windows tool) for same tool as traceroute
- Udemy Practice test _2 Question 48
Traceroute works by increasing the "time-to-live" value of each successive batch of packets sent. The first three packets
have a time-to-live (TTL) value of one (implying that they make a single hop). The next three packets have a TTL value of 2,
and so on. When a packet passes through a host,normally the host decrements the TTL value by one,and forwards the packet to
the next host. When a packet with a TTL of one reaches a host,the host discards the packet and sends an ICMP time exceeded
(type 11) packet to the sender. The traceroute utility uses these returning packets to produce a list of hosts that the
packets have traversed en route to the destination.

- The Ping of Death first appeared in 1996 because applications misinterpreted oversized packets.

- ip addr // for seeing IP related data

- ifconfig              // to show ethernet settings and other internet config things, if 'eth0' is their in o/p then it means
                        // their is wired connection , if u see 'wlan0' then it is wireless connected, additional ethernet
                        // connections would be shown as 'eth1' and so on
                        // 'lo' is a loop back interface which is a special interface which system uses to communicate with
                        // itself, 'inet addr' is the local are LAN address or NAT address, 'RX packets' is the received packet
                        // 'TX packet' is the transmitted packet
- ifconfig eth1         // it will now show details for 'eth1' interface only
- ifconfig eth0 up      // this will enable the internet connection
- ifconfig eth0 down    // this will disable the internet connection

- ipcalc ip_Address   // very usefull tool to understand Network segments such as Host, Network, Network Type, range etc

- 'netstat' it is a cmd line tool that is used to display network connections, routing tables and network interfaces, it can
be used to see network protocol statics
- netstat -ie // gives same output as ifconfig
- netstat -r  // to display routing table
- netstat -c // display all continous listening services
- netstat -a // display all current connections
- netstat -at | less  // this will show only tcp connections
- netstat -l | less   // this show the programs which r in listening state
- netstat -lt | less   // this will show u listening tcp connection
- netstat -lu | less   // this will show u listening udp connection
- netstat -s | less   // this will show u the statictics such as the ip packets received and delivered
- netstat -st | less  // to see statistics for the packets recived and delivered packets in tcp connection
- netstat -su | less  // to see statistics for the packets recived and delivered packets in udp connection
- netstat -p | less  // to see the pid of all connection which r available
- netstat -n | less  // to see the numberic ports which r being used by different interfaces in ur system
- netstat -an | grep  ':80'// now it will show the output for the connections with the grep entered pattern of text
- netstat -ano // it will show that which port of ur computer is connected to the port of another computer in Local Address
and Foreign Address and the if the connection is their between the local and Foreign address then the "state" would be
"established" and also tell the process ids so we can check from their that what service connection is established their such
as Dropbox or a hacker is using it. 

- impt cmd -> netstat -rnv 

- tcpdump -D // lists the interfaces which tcpdump is capable of Listening or capture from
- tcpdump -i interface_name -nn // to capture traffic on particular interface, -nn will display the ports instead of protocol 
  Ex -> http will be shown as 80 using -nn
- tcpdump -w file_name.pcap '(src src_IP and dst dst_IP) or (src src_IP and dst dst_IP)' // to capture packets on desired 
hosts networks, -w is to write captured data to file with extension pcap
- tcpdump -r file_name.pcap // to read file with captured packets
- tcpdump host host_ip_address port 80 // use 'port' to define port
- tcpdump -i eth0 -v src port 443 and dst dst_IP_address // here we r defining src port and and destination IP address
- tcpdump -i eth0 tcp net 192.168.1.0/24  // to capture traffic on subnet and only show TCP data only

Note -> use tcpdump to capture traffic and wireshark to analyse traffic



 arp -a // it will list the table of IP addresses with their corresponding MAC addresses, The ARP is used to find the MAC 
 address for Known IP addresses and the RARP(Reverse ARP) is to find IP addresses for known MAC addresses

- ethtool nic_interface_name // provide info for the interface NIC

- lo // the loopback device is a special interface that ur computer uses to communicate with itself, It is mainly used for
diagnostics and troubleshooting, and to connect to servers running on the local machine

# NIC Bonding -> NIC  bonding is also known as network bonding, It can be defined as the aggregation or combination of multiple
NIC into a single bond interface, It's main purpose is to provide high availability and redundancy

If u combine two NIC of 1 GB then it will provide 2GB and if one fails the other would be still working, Screenshot(529)

NIC bonding Procedure ->
- modprobe bonding -> it is to get the configuration of ur driver
- modinfo bonding -> to get the info of ur bonding
- Create the file -> /etc/sysconfig/network-scripts/ifcfg-bond0 then edit file -> /etc/sysconfig/network-scripts/ethernet1
and file -> /etc/sysconfig/network-scripts/ethernet2
then u point the 1st edit and 2nd edit ethernet files to ifcfg-bond0 
then restart the network via cmd -> systemctrl restart network, Screenshot(530)
To do above task -> https://academy.ehacking.net/courses/551622/lectures/10003630 in virtualbox

wget // to download the files and apps in linux
Ex -> wget http://website.com/file_to_download

- Ping cmd will let u know if server is up but not that if the page on that server, hence to check that page we need the
'curl' cmd
	Ex -> curl http://website.com/filename // to check if page is up, in return it sends the page script
		  curl -O http://website.com/filename  // if u wants to download a file, u can use this cmd in case the wget is
												// not working
												
	File transfer cmds ->
	
	- ftp -> Ex -> Screenshot(533) 
			To transfer the file to the server whoch is not running FTP daemon, we will try to load FTP on local
			host as
			cmd -> ftp system_hostname // if daemon is not present it will say connection refused but still give
			ftp prompt 
	- scp -> Ex - scp filename remote_host:path_to_copy 
	- rsync // this is used by system admins to backup files to another system mostly using through cron job

- System update and repos ->

- apt-get is used for this task

Note -> In some companies internet access is not allowed, In that case repos r setup locally on another server within
the same network 

- rmp (RedHat Package Manager) -> It is used when u already have package downloaded in ur system and u can install it
locally using rpm while yum does all the things for u it downloads the package and installs aswell and then clean up the
downloaded the package form the system
cmd -> rpm -qa // q to query all the packages in system and list them 
	   rpm -ihv path_to_package.rpm // on running this it will install package
	   rpm -e package_name // to remove a package

- Two types of upgrades in Linux ->
	- Major Version upgrade from 5 to 6
	- Minor Version upgrade from 7.1 to 7.2
	
	The difference in update and upgrade is that upgrade delete packages while update preserves the old packages
	
- To create Local repository form CD/DVD -> https://academy.ehacking.net/courses/551622/lectures/10003634

- Advance Package Management ->
 - 

Shell_Scripting  ->

Bash scripts allow u to execute cmds from a file, Here interpretor is the Shell which gives u too much funtionalities, So if
we r using Bash script it will work pretty much every time without installing the dependencies or additional extensions or
additional modules
Shell is basically the interface between us and UNIX kernal, UNIX kernal basically manages the systems resources or we can
say hardware Shell is accessed using the terminal

So the thing like 'madhur@ubuntu:-$' here madhur is the username and $ represents the shell

to check the shell types ur system supports use cmd-> cat /etc/shells
to know where bash is located cmd -> which bash

to create a file cmd -> touch hello.sh  //.sh extention is not necessary but for editor it is usefull and it is also best
practice

Types of Shell ->
- Gnome // it is like Graphical environment that is in linux via GUI
- KDE // It is also GUI
- sh // it is main shell
- bash // it is enhanced of 'sh' 
- csh and tcsh // this is C shell, C shell does not run bash scripts
- ksh // it is basically used for Solaris

cmd -> cal // to view the calender

Bash Scripting is preferred more then Python bcz Shell is built in Unix and that means u can utilize the entire unix tool set
With Bash Scripting, File Management is fully automated(Copy file, update file etc)
Bash is not that gud like python for analytics and Big Data, it is more for controlling the system and automating tasks

extension is .sh for shell scripts

- to display a string use echo on terminal ->echo hello  o/p-> hello
- in the editor ->
 #!/bin/bash        // declaring then bash interpretor, bash is terminal instance which give u much more stream lined linux
 		    // experience
 #!/bin/sh          // declaring the shell interpretor, this does not gives u full functionalities
 #!/bin/python

 echo "Hello World"

 if in the pyhton script the interpretor is not defined like this '#!/bin/python' and we try to execute the script like 
 this ./filename then it will give the invalid argument specification error

 if u do cmd -> ls -al
 then u will see as -rw-rw-r-- // here the 1st -rw means the read and write for u
 2nd -rw means read and write for the group and 
 3rd r-- means read only permission for the user, rwx means the read write and execute

 if the tab is not completing the script then check the permissions for the file whether it is only read by doing 
 cmd->'ls -al'
 and if it having 'r--' in the file specification then it is only read file, to change the specifications of the file u can
 do cmd -> 'chmod +x file_name'
 to revert the permissions use 'chmod -x file_name' cmd

- Variables ->

Their r two types of variables -> System Variables and User Defined Variables
System Varaibles -> These r created or maintained by Linux OS. // generally these variables r in Capital letters
Ex: $BASH // this gives u the bash shell name, echo $BASH o/p-> /bin/bash
$BASH_VERSION
$HOME  // this gives u home directory
$PWD

User Defined Variables ->

NAME="Sadanand"  // variable name should be always in Uppercase and no spaces after the variable and after the 
		 // assignment operator
SPORT="Foot"
echo "My name is $NAME" // to call a variable use the $ before the variable
echo "The most famous sport is ${SPORT}ball"  // here we use the $ with curry braces for doing the concatenation of Strings

- User Inputs and Comments ->

read -p "Enter your Name: " NAME   // to get the user input -p is for prompt msg and 'NAME' is the variable in which it
echo "Your name is $NAME"          // is going to store the input value and 'read' tells to read from terminal
# User input                       // # is ur for comment

read -sp "Enter ur Password: " PASSWORD   // with this the variable will get the value but not show on the o/p screen
echo PASSWORD

echo "Enter Names"
read -a names                           // this is to read a arrray ,So if input is -> tom max
echo "Names: ${names[1]}"               // o/p is -> max

echo "Enter Name"
read                                  // using no variable
echo "Name: $REPLY"                   // $REPLY is a built in variable to get the latest read input data

echo -e "Enter your Full name \c"  // \c is used to keep the cursor on the same line and -e is used for \c otherwise it will
			           // print \c
read FNAME LNAME        // to get the data into variables now in FNAME the 1st input string will come and in LNAME the 2nd
			// input string

#in terminal after executing the script
Enter ur Full name
Sadanand Sharma         // here the user has entered the Input and Sadanand will go in FNAME and Sharma will go in LNAME

- Conditional Statements ->
Synatx if statement->
if [ condition ];    // always use the space between the bracket '[' and the condition staement
then
    statement to be executed        // use indent after the next line of then as the best practice
fi

Ex if statement->
NAME="Sadanand"
if [ "$NAME" = "Sadanand" ];       // always use the quotation on the variable always use the space between the varibale and = bcz
then                               // if u do like this "$NAME"="Sadanand" this means assignment instead of checking equal
    echo "Welcome $NAME"
fi                                  // to end the condition execution

Synatx if else statement->
if [ condition ];    // always use the space between the bracket '[' and the condition staement
then
    statement to be executed        // use indent after the next line of then as the best practice
elif                                // else if statement
then
    statement
else
    statement to be executed
fi

contional Operator we can use -> -eq //is equal to, -ne // is not equal to, -gt //is greater than, -ge //is greater than or equal to,
-lt //is less than, -le // is less than or equal to

EX-> if [ "$a" -eq "$b"]

for using the sign operators

Ex-> if (("$a" < "$b"))    // u need to use (( )) brackets for using the sign operators

For string comparisions ->
= //is equal to, == //is equal to, != //is not equal to, < , >, -z // string is null or has zero length
EX -> if [ "$a" = "$b" ]    // for string we need not to use the (())
in ASCII alphabetical order ->   if [[ "$a" < "$b" ]]

- Test Scripts ->
- cmd -> help test // to open the documentation for the test cmd
- nano file_name // to open the file in editor and then ctrl+o to save

if [ -d /usr/share/wordlists ];         // to check for the file use -e in place of -d which is to check for directory condition will
then                                        // will be if [ -e /usr/share/wordlists/rockyou.txt ];
    echo "Yes it exists"
else
    echo "The file does not exists"
fi

Same way we have other cmds too such as:
if [ -f /usr/share/wordlists/rockyou.txt ];    // to check if file or not

Their r two types of files block special file ans character special file , Character special file is a normal file which contain data
or text and Block special file is the binary file or picture file or video file

if [ -b /usr/share/wordlists/rockyou.txt ];    // to check for block special file
if [ -c /usr/share/wordlists/rockyou.txt ];    // to check for character special file
if [ -s /usr/share/wordlists/rockyou.txt ];    // to check whether file is empty or not
if [ -r /usr/share/wordlists/rockyou.txt ];    // to check for the read permission
if [ -w /usr/share/wordlists/rockyou.txt ];    // to check for the write permission
if [ -x /usr/share/wordlists/rockyou.txt ];    // to check for the execute permission
if [ -e /usr/share/wordlists/rockyou.txt ];    // if file exist or not

use cmd -> ls -l to check the file details and size of it

cmd -> cat > file_name // to write something in the file
use ctrl+d to come out of cat cmd

- For Loops ->
Syntax ->
for VARIABLE in $(); do
    commands
done

Ex: ->
nano list.txt   // this file to create a list

Alexis
John
Superman        // creating a list in file list.txt

ctrl+o

for NAMES in $(cat list.txt); do          // cat cmd is for fast execution when u r reading the information
    echo "The names r: $NAMES"
done

// then execute the file

- Ping Sweep Script         // this is to ping on subnet and do diagnosis

man ping // to get the documention of ping cmd

echo "Please enter the subnet"
read SUBNET                     // enter the first three ranges of the IP4 such as 192.168.1
for IP in $(seq 1 254); do      // here we r specifying the range
    ping -c 1 $SUBNET.$IP                  // -c is for count the no. of times u wannna ping it otherwise it will keep going
done

// then execute the file

- Password Generator ->

-library used here is open SSL which is used by transport layer to secure various aspects of security such as websockets etc

echo "This is a Simple Password Genrator"
echo "Plz enter the length of the Password"
read PASS_LENGTH

for p in  $(seq 1); do          // to increase the variety of password increase the seq no. form 1 to further like $(seq 1 5);
    openssl rand -base64 48 | cut -cl-$PASS_LENGTH // rand for random characters, 48 is for the no. of characters , cut operator
done                                            //to cut the  password -cl to cut the column
// So basically here we r using openssl library to generate random password characters in base64 format through the whole
character range og base64 which is 48 then we r filtering it and cutting it to the first character to the password length the
user has specified , we can use 'hex' in place of 'base64' but we base64 for is better we bcz brute force attack is difficult on it

- Functions ->

Syntax ->

function func_name(){      // the function should be declared first then called
    // code to put
}
func_name  // calling the function

Ex ->

function test_shadow(){
if[ -e /etc/shadow ];
then
    echo "It exists"
else
    echo "The file does not exist"
fi
test_password      // calling the function with the function
}

function test_password(){
if[ -e /etc/password ];
then
    echo "It exists"
else
    echo "The file does not exist"
fi
}

test_shadow

- Positional Parameters ->

./file_to_be_executed input_to_be_passed   // to pass data to the script

- positional parameters are ranged from 0 to 9 and they r denoted by $ as $0 - $9
So ./file_name 10 name // So the 10 is given to $1 and name is given to range to $2

echo "Excetution of File: $0 $1"  o/p -> Excetution of File: file_name 10

to pass arguments in bash script as array

args=("$@")    //$@ stores the argument as an array , So if Input is ->./filename  tom mark

echo ${args[0]}  // o/p is tom , the index 0 is not taking the filename as the input

echo $@   // o/p is -> tom mark

echo $#     // to count the no. of arguments ,So o/p is 2

- File Encrypter and Decrypter
// gpg allows u to encrypt data and genrate keys

echo "This is a simple file encrypter/decrypter"
echo "Plz choose what u want to do"

choice="Encrypt Decrypt"  // this the list

select option in $choice; do   //  this is show the options from the list and assign the numbers to them
   if [ $REPLY=1 ];         // $REPLY is associated with select option it is predefined and 1 defines the Encrypt from the List
then
    echo "You have selcted Encryption"
    echo "Please enter the file name"
    read file;
    gpg -c $file    // this is to encrypt the file
    echo "The file is encrypted"
else
    echo "You have selcted Decryption"
    echo "Please enter the file name"
    read file2;
    gpg -d $file2    // this is to decrypt the file
    echo "The file is decrypted"
fi
done

Note: if the file has beed executed from the same computer for decryption then the passphrase for decryption would not been asked
bcz the data keys r stored for us by the gpg in our computer but if we run the file from the another computer then it will ask for
the passphrase

- How to append text to an File?

echo -e "Enter the file name : \c"
read file_name

if [ -f $file_name ];
then
    if [ -w $file_name ]
    then
       echo "Type some data. To quit press Ctrl + D"
       cat >> $file_name      // >> is used for appending by cat and > is used for overwriting the file
    else
       echo "The file do not have write permissions"
    fi
    echo "$file_name a valid file"
else
    echo "$file_name not a valid file or not exists"
fi

cmd -> chmod -w file_name // to do not writable permissions of the file and use +w for providing write permissions

-  Logical AND Operator
their r three ways of AND operators for IF
1-> if [ "$age" -gt 18  ] && [ "$age" -lt 30 ]
2-> if [ "$age" -gt 18  -a "$age" -lt 30 ]     // -a stands for AND
3-> if [[ "$age" -gt 18 && "$age" -lt 30 ]]

- Logical OR Operator
their r three ways of OR operators for IF
1-> if [ "$age" -gt 18  ] || [ "$age" -lt 30 ]
2-> if [ "$age" -gt 18  -o "$age" -lt 30 ]     // -o stands for OR
3-> if [[ "$age" -gt 18 || "$age" -lt 30 ]]

- Arthemetic Operations ->
echo 1+1 , o/p is -> 1+1, Bcz echo just throw what is mentioned in it
So,

num1=20
num2=5
echo $((num1+num2)) ,  o/p -> 25

another way is using the 'expr' cmd

echo $(expr $num1 + $num2)
echo $(expr $num1 \* $num2)  // this \ is only to be used with multiplication while using expr cmd

- Floating Point math operation ->

- By default scripting doesn't support decimal no. we need to use tools for it
- cmd -> man bc // manual for basic calculator
So we can do as -> echo "20.5+5" | bc // this means that whaterver we have done on the left side of the pipe filter will be treated as the
cmd for the right hand side

echo "20.5/5" | bc ,o/p is 4
to do above division correctly use scale as
echo "scale=2;20.5/5" | bc ,here scale=2 means upto 2 decimal places ,o/p is 4.10
So always use 'scale' for the divisions in floating points
num=27
echo "scale=2;sqrt($num)" | bc -l  // we have to use -l because we r using math library sqrt
echo "scale=2;3^3" | bc -l   // this is to get the power of no. means 3 to the power, 3 o/p -> 27

- Case Statement

Syntx ->
case expression in
    pattern1 )
       statements ;;
    pattern2 )
       statements ;;
    ....
esac

Ex: ->
vehicle=$1            // taking the user input
case $vehicle in
   "car" )
      echo "U choosed Car";;
   "van" )
      echo "U choosed Van";;
   [a-z] )                       // this is for regex u can use all the regex expressions for case also
      echo "U choosed Pattern";;
   * )                           // this '*' is for default case
      echo "Wrong Option Choosed"
esac

if u enter the capital letter and still in ur scrit it does not recognize it in the pattern case as the capital letter the go on the
terminal and cmd -> LANG=C // The 'LANG' environment variable indicates the language /locale and encoding, where 'C' is the lamgauge setting

- Array ->
os=('ubuntu' 'windows' 'kali')   // this is the way to create an array
echo "${os[@]}"   // this will print all the elements of array
echo "${!os[@]}"    // using ! will print all the indexes of the array
echo "${#os[@]}"   // this will give the length of the array

os[3] = 'mac'     // this will add the element to array

unset os[2]     // this will remove the element from the array unset is a predefined cmd but the output for the echo "${!os[@]}" is 0 1 3
// in the shell the positions r not shifted means their could be Gaps in the array

string=Hello
echo "${string[@]}"  op -> Hello
echo "${string[0]}"  op -> Hello
echo "${string[1]}"  op ->     // blank, So u can treat any variable as an array but the array is assigned to the 0 index only
echo "${#string[@]}"  op -> 1

- While Loops ->
Syntax ->
while [ condition ]
do
   command1
   command2
   command3
done

EX:->
n=1
while [ $n -le 10 ]      // u can use the If statement changes for conditions such as using (()) etc
do
   echo "$n"
   n=$((n+1))      //or u can use here (( ++n ))
   sleep 1        // this is for the pause of 1 sec
done

// to open the terminals

cmd -> gnome-terminal &    // this is only for ubuntu so check ur terminal

- Read files using while loop ?

while read p   // p is the variable to save the content
do
  echo $p
done < hello.sh // here the input redirection menas where ever the pointed arraow is the stream goes to that direction here on left side '<'
which means here to the while loop

o/p whould be the whole file content will be printed

- another way using pipe

cat hello.sh | while read p // this means whatever content is read using cat cmd is now like a input for this while cmd
do
  echo $p
done

o/p whould be the whole file content will be printed

- .bashrc file is a script that is executed whenever a new terminal session is started in interactive mode
- when u do -> ls -a , in ur root directory u can see a file .bashrc in the list, whenever u open a new terminal this .bashrc
  file is executed
- nano .bashrc          // to see the contents of the file
- gedit .bashrc         // this will also open the file, gedit is also an notepad kind of editor
- In some linux systems this .bashrc file exists and in some not, if it is present then it is OK otherwise u can create ur own
- whatever u add in to the script of the bashrc file it will we executed first whenever u open a new terminal session
- Ex -> edit and add -> echo "This is test code" in the .bashrc file and the text will we displayed when ever u open terminal 
- or try adding code -> alias ls='ls --color=auto -l' in the .bashrc file and now when ever u will do 'ls' it will do 'ls -l'
  with the auto color. So here we changed the functionality of 'ls' cmd with 'ls -l'
- We generally use .bashrc file for setting up the environment variables such as for JAVA, or for git etc

- unalias alias_name // to remove the alias name for the cmds 


